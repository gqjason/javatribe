>深夜:我了不起 清晨:我起不了

# 每日两题
---


# 一、基础题
### 题目：[P1022 [NOIP 2000 普及组] 计算器的改良](https://www.luogu.com.cn/problem/P1022)

### 思路：
比较复杂的模拟题。注意细节即可。
### 代码(c++)：
时间复杂度 **O($len(s)$)**，`s`为输入的字符串。

```cpp
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;

// 把已读取的纯数字并入常数项（统一放到等号左侧）
inline void Flush(long long &constant, long long &num, int side, int sign, bool &hasNum) {
    if (hasNum) {
        constant += side * sign * num;
    }
    num = 0;
    hasNum = false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    if (!(cin >> s)) return 0;

    long long coeff = 0;    // 未知数系数累加
    long long constant = 0; // 常数项（移到等号左侧）
    long long num = 0;      // 当前累积数字
    int sign = 1;           // 当前项符号
    int side = 1;           // 左边：+1；右边：-1
    bool hasNum = false;    // 是否已有数字
    char var = 0;           // 未知数名

    for (char c : s) {
        if (c == '+') {
            Flush(constant, num, side, sign, hasNum);
            sign = 1;
        } else if (c == '-') {
            Flush(constant, num, side, sign, hasNum);
            sign = -1;
        } else if (c == '=') {
            Flush(constant, num, side, sign, hasNum);
            sign = 1;
            side = -1;
        } else if (c >= '0' && c <= '9') {
            num = num * 10 + (c - '0');
            hasNum = true;
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            var = c;
            long long k = hasNum ? num : 1;
            coeff += side * sign * k;
            num = 0;
            hasNum = false;
        }
    }
    Flush(constant, num, side, sign, hasNum);

    // coeff * var + constant = 0
    double ans = -static_cast<double>(constant) / static_cast<double>(coeff);
    if (ans == -0.0) ans = 0.0;

    cout << var << '=' << fixed << setprecision(3) << ans;
    return 0;
}
```

# 二、提高题
### 题目：[P8620 [蓝桥杯 2014 国 A] 排列序数](https://www.luogu.com.cn/problem/P8620)

### 思路：
(经典的蓝桥杯暴力题，暴力即可，题解结束【bushi】🤣🤣🤣)
经典的康托展开题。
康托展开用于计算一个排列在所有排列中的字典序排名。对于一个长度为 $n$ 的排列，从左到右依次确定每一位，统计当前位左侧未出现且比当前字符小的字符个数 $cnt$，则该位对排名的贡献为 $cnt \times (n-i-1)!$。将所有位的贡献累加即为该排列的序数（从 $0$ 开始计数）。

本题直接按照康托展开公式模拟即可，注意每次要维护已出现的字符集合。

**三倍经验**：[[力扣]31. 下一个排列](https://leetcode.cn/problems/next-permutation/description/)
**四倍经验**：[[力扣]60. 排列序列](https://leetcode.cn/problems/permutation-sequence/description/)
**五倍经验**：[P5367 【模板】康托展开](https://www.luogu.com.cn/problem/P5367)

可能需要的知识：
- 康托展开：
学习网站：[维基百科](https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80)，B站：[算法讲解146【扩展】康托展开、约瑟夫环、完美洗牌【左程云】](https://www.bilibili.com/video/BV1Dz2eYTE7T/?spm_id_from=333.337.search-card.all.click)

### 代码(c++)：
时间复杂度 **O($n^2$)**，其中`n`为字符串长度。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll fact[20];

// 预处理阶乘
void pre() {
    fact[0] = 1;
    for (int i = 1; i < 12; ++i) {
        fact[i] = fact[i - 1] * i;
    }
}

void solve() {
    pre();
    string s;
    cin >> s;

    int len = s.length();
    vector<char> used;
    ll ans = 0;

    for (int i = 0; i < len; ++i) {
        // 二分查找比当前字符小且已出现过的字符个数
        int idx = upper_bound(used.begin(), used.end(), s[i]) - used.begin();

        int cnt = (s[i] - 'a' - idx);//比当前字符小且未出现过的字符个数
        ans += cnt * fact[len - i - 1];

        used.insert(used.begin() + idx, s[i]);//把字符插入used数组
    }
    cout << ans << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}
```

