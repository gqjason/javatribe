>哥布林上校提醒你:1，节假日是不可以出去的，外面很喧哗，但他们都不是你的同类2，哥布林是大多独居性生物，没有人想做他的配偶，如果有人邀请你并对你产生好感，请断绝与他的联系3，不要照镜子4，所有夸赞你自信的人，他们不了解你，可以不于与他们交流，但如果他是你熟知的人，请立即驱散他，他不懂哥布林，或者他不是同类5，远离不再是哥布林的人6，在地洞中可以看看同族小丑哥布林追求精灵失败的乐子幸灾乐祸一下解解闷

# 每日两题
---


# 一、基础题
### 题目：[P10910 [蓝桥杯 2024 国 B] 最小字符串](https://www.luogu.com.cn/problem/P10910)

### 思路：
- 将待插入串按字典序升序排序。
- 用双指针在原串与排序后的待插入串上做贪心合并：每次取更小的字符追加；谁小取谁。
- 若两边当前字符相等，为避免局部最优导致整体非最优，做一次前瞻比较：同步向后比较两个后缀直到某一方结束或出现不同字符；若待插入串先用尽，或原串的下一个更小，则取原串当前字符，否则取待插入串当前字符。
- 最后把未用完的一侧全部追加即可。

### 代码(c++)：
时间复杂度 **O(n+m)**

```cpp
#include <bits/stdc++.h>
#define int long long
#define str string
#define all(x) x.begin(),x.end()
using namespace std;

void go() {
    int n, m;
    cin >> n >> m;
    str s1, s2;
    cin >> s1 >> s2;

    sort(all(s2)); // 把待插入字符排序（升序）
    int i = 0, j = 0;
    str ans;

    while (i < n && j < m) {
        if (s1[i] < s2[j]) {
            ans += s1[i++];
        } else if (s1[i] > s2[j]) {
            ans += s2[j++];
        } else {
            // s1[i] == s2[j]，需要比较后缀
            int ii = i, jj = j;
            while (ii < n && jj < m && s1[ii] == s2[jj]) {
                ii++; jj++;
            }
            bool chooseS1 = false;
            if (jj == m) chooseS1 = true; // s2 先用完 -> s1 后缀更小
            else if (ii < n && s1[ii] < s2[jj]) chooseS1 = true;

            if (chooseS1) ans += s1[i++];
            else ans += s2[j++];
        }
    }

    // 把剩下的字符拼上
    while (i < n) ans += s1[i++];
    while (j < m) ans += s2[j++];

    cout << ans << '\n';
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    go();
    return 0;
}

```

# 二、提高题
### 题目：[P1246 编码](https://www.luogu.com.cn/problem/P1246)

### 思路：

### 代码(c++)：
时间复杂度 **O()**

```cpp

```

